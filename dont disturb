import os
import streamlit as st
import pandas as pd
import tempfile
import matplotlib.pyplot as plt
import seaborn as sns
from langchain.schema import Document
from langchain.prompts import PromptTemplate
from langchain.chains.question_answering import load_qa_chain
from langchain_community.chat_models import ChatOpenAI
from langchain_experimental.agents import create_pandas_dataframe_agent
from langchain_openai.embeddings import OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores.faiss import FAISS

# Set OpenAI API Key
os.environ["OPENAI_API_KEY"] = "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"  # Replace with your actual API key


@st.cache_data
def load_csv_as_documents(file_path):
    """Load CSV data and convert it into a list of documents."""
    try:
        df = pd.read_csv(file_path, na_values=["", "NA", "NaN"])
        documents = [
            Document(page_content=" ".join(row.fillna("").astype(str))) for _, row in df.iterrows()
        ]
        return df, documents
    except Exception as e:
        st.error(f"Error loading CSV: {e}")
        return None, []


@st.cache_resource
def create_embeddings_and_retriever(_documents):
    """Create embeddings and retriever for document search using FAISS."""
    embeddings = OpenAIEmbeddings()
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=200)
    chunks = [chunk for doc in _documents for chunk in text_splitter.split_text(doc.page_content)]
    faiss_index = FAISS.from_texts(chunks, embeddings)
    return faiss_index.as_retriever()


def get_model_response(documents, query):
    """Generate a response using LangChain and OpenAI."""
    try:
        retriever = create_embeddings_and_retriever(documents)
        relevant_docs = retriever.get_relevant_documents(query)

        prompt_template = """
            Given the following context and a question, generate an answer based on this context only.
            If the answer is not found in the context, state "I don't know."
            Context: {context}
            Question: {question}
            Answer:
        """
        prompt = PromptTemplate(template=prompt_template, input_variables=["context", "question"])
        model = ChatOpenAI(temperature=0.1)
        chain = load_qa_chain(model, chain_type="stuff", prompt=prompt)

        response = chain.invoke({"input_documents": relevant_docs, "question": query})
        return response.get('output_text', "I don't know.")
    except Exception as e:
        st.error(f"Error generating response: {e}")
        return "I don't know."


@st.cache_resource
def create_dataframe_agent(df):
    """Create a LangChain pandas DataFrame agent."""
    llm = ChatOpenAI(model_name="gpt-4", temperature=0)
    return create_pandas_dataframe_agent(llm, df, verbose=False, allow_dangerous_code=True)


def generate_plot_from_prompt(df, prompt):
    try:
        # Normalize column names for consistent AI inference
        df.columns = df.columns.str.strip().str.lower().str.replace(r'\s+', '_', regex=True)

        # Provide dataset context to AI
        column_info = f"""
        The dataset contains the following columns: {', '.join(df.columns)}.
        Here are some example rows:
        {df.head(3).to_string(index=False)}
        """
        detailed_prompt = f"""
        {prompt}

        {column_info}

        Based on this dataset, determine:
        1. The type of plot (scatter, bar, line, histogram, boxplot, etc.).
        2. The column for the X-axis.
        3. The column for the Y-axis (if applicable).

        Respond in the following format:
        Plot type: [plot_type]
        X-axis: [x_column]
        Y-axis: [y_column] (optional)
        """

        # Get AI response
        response = get_model_response([Document(page_content=column_info)], detailed_prompt)
        st.write("AI Response:", response)

        # Extract plot details from the AI response
        plot_type, x_axis, y_axis = None, None, None
        if response:
            response_lower = response.lower()

            # Extract plot type
            for p_type in ["scatter", "line", "bar", "histogram", "boxplot"]:
                if p_type in response_lower:
                    plot_type = p_type
                    break

            # Extract columns from the AI response
            inferred_columns = [col for col in df.columns if col in response_lower]
            if len(inferred_columns) >= 1:
                x_axis = inferred_columns[0]
            if len(inferred_columns) >= 2:
                y_axis = inferred_columns[1]

        # Fallback to manual input if AI response is incomplete
        if not plot_type or not x_axis or (plot_type in ["scatter", "line", "bar", "boxplot"] and not y_axis):
            st.warning("AI could not generate a complete response. Please specify plot details manually.")
            plot_type = st.selectbox("Select Plot Type", ["scatter", "line", "bar", "histogram", "boxplot"])
            x_axis = st.selectbox("Select X-Axis Column", [None] + list(df.columns))
            y_axis = (
                st.selectbox("Select Y-Axis Column (optional)", [None] + list(df.columns))
                if plot_type != "histogram"
                else None
            )

        # Validate plot details
        if not plot_type or not x_axis or (plot_type in ["scatter", "line", "bar", "boxplot"] and not y_axis):
            st.error("Incomplete plot details. Please ensure all required inputs are provided.")
            return

        # Generate the plot dynamically
        plt.figure(figsize=(10, 6))
        if plot_type == "scatter" and y_axis:
            sns.scatterplot(data=df, x=x_axis, y=y_axis)
        elif plot_type == "line" and y_axis:
            sns.lineplot(data=df, x=x_axis, y=y_axis)
        elif plot_type == "bar" and y_axis:
            sns.barplot(data=df, x=x_axis, y=y_axis)
        elif plot_type == "histogram":
            sns.histplot(data=df[x_axis], kde=True)
        elif plot_type == "boxplot" and y_axis:
            sns.boxplot(data=df, x=x_axis, y=y_axis)
        else:
            st.error("Invalid plot details. Please try again.")
            return

        # Render the plot
        plt.xticks(rotation=45)
        plt.title(f"{plot_type.capitalize()} plot of {x_axis} {'and ' + y_axis if y_axis else ''}")
        st.pyplot(plt)

    except Exception as e:
        st.error(f"Error generating plot: {e}")


def main():
    st.title("Chat with CSV Data")

    # Sidebar for file upload and mode selection
    uploaded_file = st.sidebar.file_uploader("Choose a CSV file", type="csv")
    mode = st.sidebar.radio("Choose Mode", ["Chat with CSV Data", "Query DataFrame Directly", "Visualize Data"])

    if uploaded_file is not None:
        try:
            with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
                tmp_file.write(uploaded_file.getvalue())
                tmp_file_path = tmp_file.name

            df, documents = load_csv_as_documents(tmp_file_path)

            if df is None or not len(documents):
                st.error("No valid documents found. Please check your CSV format.")
                return

            st.write("Preview of uploaded file:")
            st.dataframe(df.head())

            if mode == "Chat with CSV Data":
                user_input = st.text_input("Your Message:")
                if user_input:
                    with st.spinner("Processing... Please wait."):
                        response = get_model_response(documents, user_input)
                    st.write("Response:")
                    st.write(response)

            elif mode == "Query DataFrame Directly":
                dataframe_agent = create_dataframe_agent(df)
                user_input = st.text_input("Your Query:")
                if user_input:
                    with st.spinner("Processing... Please wait."):
                        response = dataframe_agent.run(user_input)
                    st.write("Response:")
                    st.write(response)

            elif mode == "Visualize Data":
                user_input = st.text_input(
                    "Describe the plot you want (e.g., 'bar graph of average rating by director')")
                if user_input:
                    generate_plot_from_prompt(df, user_input)

        except Exception as e:
            st.error(f"Error processing file: {e}")
    else:
        st.info("Upload a CSV file to get started.")


if __name__ == "__main__":
    main()
